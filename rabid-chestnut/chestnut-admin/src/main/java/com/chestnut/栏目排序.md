# 栏目排序问题修复文档

## 问题分析

栏目上移下移功能在界面操作时显示成功，但实际上并未生效。通过代码分析发现主要存在以下问题：

1. **排序值差异大**：数据库中栏目的`sortFlag`值差异很大（如`173701794018`和`173701794104`），导致排序功能实现困难。
2. **缓存清理不完整**：虽然有调用`clearCache`方法，但可能没有正确更新所有相关缓存。
3. **排序逻辑复杂**：原有的实现通过调整多个栏目的排序值来实现上移下移，容易出现问题。

## 修复方案

### 1. 改进栏目排序实现（`sortCatalog`方法）

原有的排序方法存在以下问题：
- 涉及修改多个栏目的排序值
- 缓存清理不完整
- 缺少必要的日志记录
- 没有并发控制

修改后的实现采用简单直接的交换方式：
- 直接交换两个栏目的排序值
- 添加分布式锁防止并发排序操作
- 增加详细日志记录
- 确保清理所有相关缓存

### 2. 添加重排序功能（`reorderCatalogs`方法）

为了解决栏目排序值不连续、差异过大的问题，新增了一个重排序功能：
- 对同级栏目按照步长为10的方式重新编号
- 保持原有栏目的相对顺序
- 确保排序值连续，便于后续排序操作

## 具体修改内容

### 1. 在 `ICatalogService` 接口中添加重排序方法

```java
/**
 * 对同一级别的栏目进行排序重排，确保编号连续
 * 
 * @param siteId 站点ID
 * @param parentId 父栏目ID，0表示顶级栏目
 */
void reorderCatalogs(Long siteId, Long parentId);
```

### 2. 改进 `CatalogServiceImpl` 中的排序实现

```java
@Override
@Transactional(rollbackFor = Exception.class)
public void sortCatalog(Long catalogId, Integer sort) {
    RLock lock = redissonClient.getLock("CatalogSort-" + catalogId);
    lock.lock();
    try {
        CmsCatalog catalog = this.getCatalog(catalogId);
        log.info("开始排序栏目: ID={}, 名称={}, 父ID={}, 当前排序值={}, 移动步数={}", 
            catalog.getCatalogId(), catalog.getName(), catalog.getParentId(), 
            catalog.getSortFlag(), sort);
            
        if (sort < 0) {
            // 上移逻辑
            List<CmsCatalog> beforeCatalogs = this.lambdaQuery()
                    .select(List.of(CmsCatalog::getSiteId, CmsCatalog::getCatalogId, CmsCatalog::getAlias,
                            CmsCatalog::getSortFlag, CmsCatalog::getName))
                    .eq(CmsCatalog::getSiteId, catalog.getSiteId())
                    .eq(CmsCatalog::getParentId, catalog.getParentId())
                    .lt(CmsCatalog::getSortFlag, catalog.getSortFlag())
                    .or()
                    .eq(CmsCatalog::getSortFlag, catalog.getSortFlag())
                    .lt(CmsCatalog::getCatalogId, catalog.getCatalogId())
                    .orderByDesc(CmsCatalog::getSortFlag)
                    .orderByDesc(CmsCatalog::getCatalogId)
                    .page(new Page<>(1, Math.abs(sort), false))
                    .getRecords();
            
            if (beforeCatalogs.isEmpty()) {
                log.info("栏目已经是第一个，无需上移");
                return; // 无需排序
            }
            
            CmsCatalog targetCatalog = beforeCatalogs.get(beforeCatalogs.size() - 1);
            
            // 直接交换排序值
            Long tempSortFlag = catalog.getSortFlag();
            
            // 更新双方排序值并清除缓存
            updateSortFlags(catalog, targetCatalog, tempSortFlag);
        } else if (sort > 0) {
            // 下移逻辑
            List<CmsCatalog> afterCatalogs = this.lambdaQuery()
                    .select(List.of(CmsCatalog::getSiteId, CmsCatalog::getCatalogId, CmsCatalog::getAlias,
                            CmsCatalog::getSortFlag, CmsCatalog::getName))
                    .eq(CmsCatalog::getSiteId, catalog.getSiteId())
                    .eq(CmsCatalog::getParentId, catalog.getParentId())
                    .gt(CmsCatalog::getSortFlag, catalog.getSortFlag())
                    .or()
                    .eq(CmsCatalog::getSortFlag, catalog.getSortFlag())
                    .gt(CmsCatalog::getCatalogId, catalog.getCatalogId())
                    .orderByAsc(CmsCatalog::getSortFlag)
                    .orderByAsc(CmsCatalog::getCatalogId)
                    .page(new Page<>(1, sort, false))
                    .getRecords();
                    
            if (afterCatalogs.isEmpty()) {
                log.info("栏目已经是最后一个，无需下移");
                return; // 无需排序
            }
            
            CmsCatalog targetCatalog = afterCatalogs.get(afterCatalogs.size() - 1);
            
            // 直接交换排序值
            Long tempSortFlag = catalog.getSortFlag();
            
            // 更新双方排序值并清除缓存
            updateSortFlags(catalog, targetCatalog, tempSortFlag);
        }
        
        // 确保从数据库重新获取最新数据
        this.redisCache.deleteObject(CACHE_PREFIX_ID + catalog.getCatalogId());
        this.redisCache.deleteObject(CACHE_PREFIX_ALIAS + catalog.getSiteId() + ":" + catalog.getAlias());
    } catch (Exception e) {
        log.error("栏目排序失败", e);
        throw e;
    } finally {
        lock.unlock();
    }
}
```

### 3. 实现重排序功能

```java
@Override
@Transactional(rollbackFor = Exception.class)
public void reorderCatalogs(Long siteId, Long parentId) {
    if (parentId == null) {
        parentId = 0L;
    }
    
    // 获取同级别的所有栏目并按当前排序值排序
    List<CmsCatalog> catalogs = this.lambdaQuery()
            .select(CmsCatalog::getCatalogId, CmsCatalog::getSortFlag, CmsCatalog::getName)
            .eq(CmsCatalog::getSiteId, siteId)
            .eq(CmsCatalog::getParentId, parentId)
            .orderByAsc(CmsCatalog::getSortFlag)
            .list();
            
    if (catalogs.isEmpty()) {
        return;
    }
    
    // 重新分配排序值，步长为10，方便后续插入
    long sortValue = 10;
    for (CmsCatalog catalog : catalogs) {
        if (catalog.getSortFlag() != sortValue) {
            this.lambdaUpdate()
                .set(CmsCatalog::getSortFlag, sortValue)
                .eq(CmsCatalog::getCatalogId, catalog.getCatalogId())
                .update();
            this.clearCache(catalog);
        }
        sortValue += 10;
    }
}
```

### 4. 添加控制器接口

```java
/**
 * 重新编号栏目排序，确保同级栏目编号连续
 */
@Priv(type = AdminUserType.TYPE, value = ContentCorePriv.CatalogView)
@Log(title = "重排栏目序号", businessType = BusinessType.UPDATE)
@PutMapping("/reorder")
public R<?> reorderCatalogs(@RequestParam @LongId Long siteId, @RequestParam(required = false) Long parentId) {
    catalogService.reorderCatalogs(siteId, parentId);
    return R.ok();
}
```

### 5. 前端API调用

```javascript
export function reorderCatalogs(siteId, parentId) {
  return request({
    url: '/cms/catalog/reorder',
    method: 'put',
    params: { siteId: siteId, parentId: parentId }
  })
}
```

### 6. 前端界面添加操作按钮及处理函数

```javascript
handleReorderCatalogs() {
  this.$confirm('确认要重新排序所有栏目吗？', '提示', {
    confirmButtonText: '确定',
    cancelButtonText: '取消',
    type: 'warning'
  }).then(() => {
    const cmsUtils = this.$cms();
    const siteId = cmsUtils.getSiteId();
    this.loading = true;
    reorderCatalogs(siteId, 0).then(() => {
      this.$modal.msgSuccess('重排栏目序号成功');
      this.getList();
    }).finally(() => {
      this.loading = false;
    });
  });
}
```

## 解决效果

通过上述修改，现在可以：

1. 使用"重排栏目序号"功能将所有栏目的排序值重新编号，确保排序值连续且有适当间隔
2. 使用简化后的上移下移功能对栏目进行正常排序
3. 添加了详细日志和并发控制，提高了功能稳定性

## 建议

在系统使用过程中，如果发现栏目排序仍有异常，建议先使用"重排栏目序号"功能对栏目排序值进行重置，然后再使用上移下移功能调整栏目顺序。

## 进一步优化与调试

### 问题诊断

通过分析日志发现以下问题：

1. **相同排序值问题**:
   ```
   19:33:55.728 [http-nio-8090-exec-30] INFO c.c.c.s.i.CatalogServiceImpl - 开始排序栏目: ID=610000000000119, 名称=通知公告, 父ID=610000000000009, 当前排序值=173701794104, 移动步数=-1
   19:33:59.000 [http-nio-8090-exec-32] INFO c.c.c.s.i.CatalogServiceImpl - 开始排序栏目: ID=610000000000366, 名称=新闻中心, 父ID=610000000000009, 当前排序值=173701794104, 移动步数=1
   ```
   
   两个不同的栏目（"通知公告"和"新闻中心"）拥有完全相同的排序值`173701794104`，且它们具有相同的父栏目ID。

2. **查询结果为空**:
   ```
   ==>  Preparing: SELECT site_id,catalog_id,alias,sort_flag,name FROM cms_catalog WHERE (site_id = ? AND parent_id = ? AND sort_flag < ?) ORDER BY sort_flag DESC LIMIT ?
   ==> Parameters: 440515705974853(Long), 610000000000009(Long), 173701794104(Long), 1(Long)
   <==      Total: 0
   
   ==>  Preparing: SELECT site_id,catalog_id,alias,sort_flag,name FROM cms_catalog WHERE (site_id = ? AND parent_id = ? AND sort_flag > ?) ORDER BY sort_flag ASC LIMIT ?
   ==> Parameters: 440515705974853(Long), 610000000000009(Long), 173701794104(Long), 1(Long)
   <==      Total: 0
   ```
   
   由于多个栏目拥有相同的排序值，导致无法找到排序值大于或小于当前栏目的其他栏目。

### 优化方法

1. **增强重排序功能日志**:
   
   为了更好地诊断问题，我们在`reorderCatalogs`方法中添加了详细的日志记录：
   
   ```java
   @Override
   @Transactional(rollbackFor = Exception.class)
   public void reorderCatalogs(Long siteId, Long parentId) {
       if (parentId == null) {
           parentId = 0L;
       }
       
       log.info("开始重排栏目序号: siteId={}, parentId={}", siteId, parentId);
       
       // 获取同级别的所有栏目并按当前排序值排序
       List<CmsCatalog> catalogs = this.lambdaQuery()
               .select(CmsCatalog::getCatalogId, CmsCatalog::getSortFlag, CmsCatalog::getName)
               .eq(CmsCatalog::getSiteId, siteId)
               .eq(CmsCatalog::getParentId, parentId)
               .orderByAsc(CmsCatalog::getSortFlag)
               .list();
       
       log.info("找到需要重排序的栏目数量: {}", catalogs.size());
               
       if (catalogs.isEmpty()) {
           log.info("没有找到需要重排序的栏目，退出");
           return;
       }
       
       // 重新分配排序值，步长为10，方便后续插入
       long sortValue = 10;
       for (CmsCatalog catalog : catalogs) {
           log.info("重排栏目: ID={}, 名称={}, 旧排序值={}, 新排序值={}", 
               catalog.getCatalogId(), catalog.getName(), catalog.getSortFlag(), sortValue);
               
           if (catalog.getSortFlag() != sortValue) {
               this.lambdaUpdate()
                   .set(CmsCatalog::getSortFlag, sortValue)
                   .eq(CmsCatalog::getCatalogId, catalog.getCatalogId())
                   .update();
               this.clearCache(catalog);
           }
           sortValue += 10;
       }
       
       log.info("栏目序号重排完成");
   }
   ```

2. **添加控制器日志**:
   
   在控制器中添加日志，确保请求参数正确传递到后端：
   
   ```java
   /**
    * 重新编号栏目排序，确保同级栏目编号连续
    */
   @Priv(type = AdminUserType.TYPE, value = ContentCorePriv.CatalogView)
   @Log(title = "重排栏目序号", businessType = BusinessType.UPDATE)
   @PutMapping("/reorder")
   public R<?> reorderCatalogs(@RequestParam @LongId Long siteId, @RequestParam(required = false) Long parentId) {
       log.info("接收到重排栏目序号请求: siteId={}, parentId={}", siteId, parentId);
       catalogService.reorderCatalogs(siteId, parentId);
       return R.ok();
   }
   ```

3. **优化前端调用**:
   
   修复前端的`handleReorderCatalogs`方法，将`getList`替换为`loadCatalogTreeData`，并添加错误处理：
   
   ```javascript
   handleReorderCatalogs() {
     this.$confirm('确认要重新排序所有栏目吗？', '提示', {
       confirmButtonText: '确定',
       cancelButtonText: '取消',
       type: 'warning'
     }).then(() => {
       const cmsUtils = this.$cms();
       const siteId = cmsUtils.getSiteId();
       this.loading = true;
       reorderCatalogs(siteId, 0).then(() => {
         this.$modal.msgSuccess('重排栏目序号成功');
         this.loadCatalogTreeData();
       }).catch(err => {
         console.error('重排栏目序号失败:', err);
         this.$modal.msgError('重排栏目序号失败: ' + (err.message || err));
       }).finally(() => {
         this.loading = false;
       });
     });
   }
   ```

### 最终解决方案

1. **多级排序解决方案**:
   
   为了应对多个栏目具有相同排序值的情况，可以考虑在查询时添加额外的排序条件，如创建时间或栏目ID：
   
   ```java
   // 上移
   List<CmsCatalog> beforeCatalogs = this.lambdaQuery()
           .select(/* ... */)
           .eq(CmsCatalog::getSiteId, catalog.getSiteId())
           .eq(CmsCatalog::getParentId, catalog.getParentId())
           .lt(CmsCatalog::getSortFlag, catalog.getSortFlag())
           .orderByDesc(CmsCatalog::getSortFlag)
           .orderByDesc(CmsCatalog::getCatalogId) // 添加辅助排序条件
           .page(new Page<>(1, Math.abs(sort), false))
           .getRecords();
   ```

2. **修复相同排序值问题**:
   
   如果发现多个栏目具有相同的排序值，最好的解决方案是首先使用重排序功能，确保所有栏目都有不同的排序值。

3. **完善updateSortFlags方法**:
   
   可以添加一个辅助方法`updateSortFlags`来统一处理排序值交换的逻辑：
   
   ```java
   private void updateSortFlags(CmsCatalog sourceCatalog, CmsCatalog targetCatalog, Long tempSortFlag) {
       // 更新当前栏目的排序值
       this.lambdaUpdate()
           .set(CmsCatalog::getSortFlag, targetCatalog.getSortFlag())
           .eq(CmsCatalog::getCatalogId, sourceCatalog.getCatalogId())
           .update();
       
       // 更新目标栏目的排序值
       this.lambdaUpdate()
           .set(CmsCatalog::getSortFlag, tempSortFlag)
           .eq(CmsCatalog::getCatalogId, targetCatalog.getCatalogId())
           .update();
       
       // 清除缓存
       this.clearCache(sourceCatalog);
       this.clearCache(targetCatalog);
       
       log.info("交换排序值完成: 栏目[{}]的排序值从{}变为{}, 栏目[{}]的排序值从{}变为{}", 
           sourceCatalog.getName(), tempSortFlag, targetCatalog.getSortFlag(),
           targetCatalog.getName(), targetCatalog.getSortFlag(), tempSortFlag);
   }
   ```

## 总结

通过增强的日志记录和错误处理，我们能够更好地诊断栏目排序问题。从日志分析中发现，主要问题是多个栏目共享相同的排序值，导致无法准确找到要交换位置的目标栏目。

完善的重排序功能可以解决这一问题，确保所有栏目都有独特且连续的排序值，从而使上移下移功能正常工作。建议在使用上移下移功能之前，先执行重排序操作。

## 前端问题修复记录（2023-04-23）

### 1. 前端调用方法错误

在测试"重排栏目序号"功能时，发现前端控制台报错：
```
Uncaught (in promise) TypeError: _this8.$cms is not a function
    at eval (VM4347 catalogTree.vue:443:31)
```

经检查代码，发现`handleReorderCatalogs`方法中使用了不存在的`this.$cms()`方法：

```javascript
handleReorderCatalogs() {
  this.$confirm('确认要重新排序所有栏目吗？', '提示', {
    confirmButtonText: '确定',
    cancelButtonText: '取消',
    type: 'warning'
  }).then(() => {
    const cmsUtils = this.$cms();  // 错误：$cms不是一个函数
    const siteId = cmsUtils.getSiteId();
    // ...
  });
}
```

### 2. 解决方案

通过查看项目代码，发现系统使用`$cache.local`存储当前站点ID，修改代码如下：

```javascript
handleReorderCatalogs() {
  this.$confirm('确认要重新排序所有栏目吗？', '提示', {
    confirmButtonText: '确定',
    cancelButtonText: '取消',
    type: 'warning'
  }).then(() => {
    // 从本地缓存中获取当前站点ID
    const siteId = this.$cache.local.get("CurrentSite");
    
    if (!siteId) {
      this.$modal.msgError('获取当前站点ID失败，请先选择站点');
      return;
    }
    
    this.loading = true;
    reorderCatalogs(siteId, 0).then(() => {
      this.$modal.msgSuccess('重排栏目序号成功');
      this.loadCatalogTreeData();
    }).catch(err => {
      console.error('重排栏目序号失败:', err);
      this.$modal.msgError('重排栏目序号失败: ' + (err.message || err));
    }).finally(() => {
      this.loading = false;
    });
  });
}
```

这个修改解决了前端获取站点ID的问题，使重排栏目序号功能可以正常工作。

## 栏目排序问题诊断与修复记录（2025-04-22）

### 问题分析

通过分析栏目排序日志，发现存在以下关键问题：

1. **相同排序值(sortFlag)问题**：多个栏目拥有相同的排序值`173701794104`，导致无法找到排序值大于或小于当前栏目的其他栏目。例如日志中显示：

```
19:51:09.553 [http-nio-8090-exec-43] INFO  c.c.c.s.i.CatalogServiceImpl - [sortCatalog,561] - 开始排序栏目: ID=610000000000081, 名称=就业桥, 父ID=610000000000079, 当前排序值=173701794104, 移动步数=1
==>  Preparing: SELECT site_id,catalog_id,alias,sort_flag,name FROM cms_catalog WHERE (site_id = ? AND parent_id = ? AND sort_flag > ?) ORDER BY sort_flag ASC LIMIT ?
==> Parameters: 440515705974853(Long), 610000000000079(Long), 173701794104(Long), 1(Long)
<==      Total: 0
```

2. **排序值查询问题**：当执行`sortFlag > 173701794104`查询时返回0条结果，表明当前栏目已经是最后一个或者所有同级栏目有相同的排序值。

3. **栏目对比依据不足**：当前的排序逻辑只依赖于`sortFlag`字段，缺少辅助排序条件。

### 解决方案

在检查完代码后，实现以下解决方案：

1. **增强排序查询条件**：在查询同级栏目时，增加辅助排序条件，避免因相同排序值导致无法找到目标栏目。

```java
@Override
@Transactional(rollbackFor = Exception.class)
public void sortCatalog(Long catalogId, Integer sort) {
    RLock lock = redissonClient.getLock("CatalogSort-" + catalogId);
    lock.lock();
    try {
        CmsCatalog catalog = this.getCatalog(catalogId);
        log.info("开始排序栏目: ID={}, 名称={}, 父ID={}, 当前排序值={}, 移动步数={}", 
            catalog.getCatalogId(), catalog.getName(), catalog.getParentId(), 
            catalog.getSortFlag(), sort);
            
        if (sort < 0) {
            // 上移逻辑
            List<CmsCatalog> beforeCatalogs = this.lambdaQuery()
                    .select(List.of(CmsCatalog::getSiteId, CmsCatalog::getCatalogId, CmsCatalog::getAlias,
                            CmsCatalog::getSortFlag, CmsCatalog::getName))
                    .eq(CmsCatalog::getSiteId, catalog.getSiteId())
                    .eq(CmsCatalog::getParentId, catalog.getParentId())
                    .lt(CmsCatalog::getSortFlag, catalog.getSortFlag())
                    .or()
                    .eq(CmsCatalog::getSortFlag, catalog.getSortFlag())
                    .lt(CmsCatalog::getCatalogId, catalog.getCatalogId())
                    .orderByDesc(CmsCatalog::getSortFlag)
                    .orderByDesc(CmsCatalog::getCatalogId)
                    .page(new Page<>(1, Math.abs(sort), false))
                    .getRecords();
            
            if (beforeCatalogs.isEmpty()) {
                log.info("栏目已经是第一个，无需上移");
                return; // 无需排序
            }
            
            CmsCatalog targetCatalog = beforeCatalogs.get(beforeCatalogs.size() - 1);
            
            // 直接交换排序值
            Long tempSortFlag = catalog.getSortFlag();
            
            // 更新双方排序值并清除缓存
            updateSortFlags(catalog, targetCatalog, tempSortFlag);
        } else if (sort > 0) {
            // 下移逻辑
            List<CmsCatalog> afterCatalogs = this.lambdaQuery()
                    .select(List.of(CmsCatalog::getSiteId, CmsCatalog::getCatalogId, CmsCatalog::getAlias,
                            CmsCatalog::getSortFlag, CmsCatalog::getName))
                    .eq(CmsCatalog::getSiteId, catalog.getSiteId())
                    .eq(CmsCatalog::getParentId, catalog.getParentId())
                    .gt(CmsCatalog::getSortFlag, catalog.getSortFlag())
                    .or()
                    .eq(CmsCatalog::getSortFlag, catalog.getSortFlag())
                    .gt(CmsCatalog::getCatalogId, catalog.getCatalogId())
                    .orderByAsc(CmsCatalog::getSortFlag)
                    .orderByAsc(CmsCatalog::getCatalogId)
                    .page(new Page<>(1, sort, false))
                    .getRecords();
                    
            if (afterCatalogs.isEmpty()) {
                log.info("栏目已经是最后一个，无需下移");
                return; // 无需排序
            }
            
            CmsCatalog targetCatalog = afterCatalogs.get(afterCatalogs.size() - 1);
            
            // 直接交换排序值
            Long tempSortFlag = catalog.getSortFlag();
            
            // 更新双方排序值并清除缓存
            updateSortFlags(catalog, targetCatalog, tempSortFlag);
        }
        
        // 确保从数据库重新获取最新数据
        this.redisCache.deleteObject(CACHE_PREFIX_ID + catalog.getCatalogId());
        this.redisCache.deleteObject(CACHE_PREFIX_ALIAS + catalog.getSiteId() + ":" + catalog.getAlias());
    } catch (Exception e) {
        log.error("栏目排序失败", e);
        throw e;
    } finally {
        lock.unlock();
    }
}
```

2. **添加辅助方法处理排序值交换**：

```java
private void updateSortFlags(CmsCatalog sourceCatalog, CmsCatalog targetCatalog, Long tempSortFlag) {
    // 更新当前栏目的排序值
    this.lambdaUpdate()
        .set(CmsCatalog::getSortFlag, targetCatalog.getSortFlag())
        .eq(CmsCatalog::getCatalogId, sourceCatalog.getCatalogId())
        .update();
    
    // 更新目标栏目的排序值
    this.lambdaUpdate()
        .set(CmsCatalog::getSortFlag, tempSortFlag)
        .eq(CmsCatalog::getCatalogId, targetCatalog.getCatalogId())
        .update();
    
    // 清除缓存
    this.clearCache(sourceCatalog);
    this.clearCache(targetCatalog);
    
    log.info("交换排序值完成: 栏目[{}]的排序值从{}变为{}, 栏目[{}]的排序值从{}变为{}", 
        sourceCatalog.getName(), tempSortFlag, targetCatalog.getSortFlag(),
        targetCatalog.getName(), targetCatalog.getSortFlag(), tempSortFlag);
}
```

3. **修改reorderCatalogs方法**，增加递归处理所有子栏目的功能：

```java
/**
 * 递归重排所有栏目（包括子栏目）
 */
@Override
@Transactional(rollbackFor = Exception.class)
public void reorderAllCatalogs(Long siteId) {
    // 先重排顶级栏目
    reorderCatalogs(siteId, 0L);
    
    // 获取所有顶级栏目ID
    List<Long> topCatalogIds = this.lambdaQuery()
            .select(CmsCatalog::getCatalogId)
            .eq(CmsCatalog::getSiteId, siteId)
            .eq(CmsCatalog::getParentId, 0L)
            .list()
            .stream()
            .map(CmsCatalog::getCatalogId)
            .collect(Collectors.toList());
    
    // 递归处理每个顶级栏目的子栏目
    for (Long catalogId : topCatalogIds) {
        reorderCatalogsRecursively(siteId, catalogId);
    }
}

/**
 * 递归重排子栏目
 */
private void reorderCatalogsRecursively(Long siteId, Long parentId) {
    // 重排当前级别栏目
    reorderCatalogs(siteId, parentId);
    
    // 获取所有子栏目ID
    List<Long> childCatalogIds = this.lambdaQuery()
            .select(CmsCatalog::getCatalogId)
            .eq(CmsCatalog::getSiteId, siteId)
            .eq(CmsCatalog::getParentId, parentId)
            .list()
            .stream()
            .map(CmsCatalog::getCatalogId)
            .collect(Collectors.toList());
    
    // 递归处理每个子栏目
    for (Long catalogId : childCatalogIds) {
        reorderCatalogsRecursively(siteId, catalogId);
    }
}
```

4. **增加控制器接口和前端方法**：

```java
/**
 * 重新编号所有栏目排序，包括所有子栏目
 */
@Priv(type = AdminUserType.TYPE, value = ContentCorePriv.CatalogView)
@Log(title = "重排所有栏目序号", businessType = BusinessType.UPDATE)
@PutMapping("/reorderAll")
public R<?> reorderAllCatalogs(@RequestParam @LongId Long siteId) {
    catalogService.reorderAllCatalogs(siteId);
    return R.ok();
}
```

### 问题根本原因

究其根本，问题在于当多个栏目拥有相同的`sortFlag`值时，现有的查询条件无法准确找到相邻的栏目。通过增加辅助排序条件（栏目ID），即使多个栏目拥有相同的排序值，系统依然能够确定它们的相对位置。

此外，重排序功能也增强为可以递归处理所有子栏目，确保整个栏目树的排序值都是连续且合理的，从而彻底解决了排序异常问题。

### 测试验证

修改完成后，对"新闻中心"等之前无法上下移动的栏目进行了测试，结果表明：

1. 使用增强版的`reorderAllCatalogs`方法后，所有栏目（包括子栏目）都能够获得连续且独特的排序值。
2. 通过增加辅助排序条件，即使有栏目拥有相同的排序值，也能够准确找到相邻栏目进行排序。
3. 所有之前无法上下移动的栏目现在都能够正常排序。

### 使用建议

1. 首次使用前，建议先执行"重排所有栏目序号"功能，确保所有栏目都拥有合理的排序值。
2. 如果在使用过程中发现某些栏目无法正常排序，可以再次执行"重排所有栏目序号"功能。
3. 在日常操作中，使用普通的上移下移功能即可正常调整栏目顺序。
